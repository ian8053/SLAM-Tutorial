各位同学,今天我们讲的是Tracking的线程,代码的详解,主要讲的Tracking这个线程,然后我们包括四个部分,第一部分是我们ORB SLAM 3的一个初始化,
第二部分是我们传感器的模块的输入,就是说我们这个图像,或者说我们单目双目RGBD,以及结合我们IMU,它的输入到底是什么样的一个情况。
第三部分是我们Tracking的指模块,就是我们Tracking它主要是怎么样处理这个数据的,它的代码逻辑是什么样子的。
然后第四部分就是我们Tracking代码的一个详解,就是我们根据按照我们实际的代码,然后每一步我们看它实现什么样的功能,让大家了解到Tracking它的具体代码是什么样子的。
好,那我们开始今天的课,正式开始。
好,那么第一部分就是我们ORB SLAM 3的一个初始化,就是说我们整个这个系统它的那个科研底盘它的结构,它是怎么样进行一个初始化的,我们看一下。
好,首先呢我们这个ORB SLAM 3,ORB SLAM 3,它的那个GitHub这个是开源的,大家都知道,这个是这个网址,就是西班牙他们那个ORB SLAM 3,他们那个团队把这些遗讯,把ORB,ORB2,ORB3这些算法它都开源的,那我们看一下。
左边的这个是,左边的这个是,左边的这个是我们这个ORB,它能够看到了一些我们这一个什么,它的一个主要的一个文件夹,我们可以看一下。
首先第一个是examples,这个examples,它主要是我们这个ORB SLAM 3的,就是说我们现在这个版本上的一些代码,然后examples old它是一些脑子代码,然后大家点开进去看,大家就应该知道这两个下面,尤其是我们examples,我们主要用的是examples,因为这个example只是我们这个SLAM 3的,根据我们传统的信贴分类的,比方说我们就有弹幕,是吧。
然后双幕还有什么,还有我们这个RGBD,以及我们弹幕跟我们IMU结合的,双幕和IMU结合的,然后另外就是说我们RGBD跟我们IMU结合的。
所以说,然后它这个里面包含的都是我们main函数,就是我们从这个代码开始处置化那个segment.cc这个文件,我们处置化的时候,然后我们实际在运行的时候,比方说我要运行我们这个RGBD的,是吧,跟IMU这个结合代码,那么它下面有个CC文件,那个CC文件是我们主函数,main函数就在那个地方。
好,那么我们再看一下我们这个第二个include,还有那个source,这个include,在这些家里面顾名思义include,它就是放投文件的地方,它主要是一些点C文件,对,点H文件,不好意思,说错了。
这个include里面是点H文件,就是我们那个投文件,好,那么那个src就是source,我们放的是那个cc或者cpp的一个原文件,我们主要是那个cc的这个,主要是在needle下面用的,我们用的一般都用那个cc,对。
好,那么另外第三个面就是我们那个third party,是吧,名字第三方库,就是我们这个陈,我们dbow2就是我们这个磁带模型的,是吧,它的这样一个,放了一个磁带模型的,另外还有什么,sophos,这个sophos用于什么呢,用于我们这个拟带数,因为有的时候我们这个旋转平移可以通过拟带数的方式去表达,那么我们这个sophos它就是一个拟带数库,对,我们可以直接就是区别,
用的,基于事业家来写的,然后还有一个什么g2o,我们这个图优化了,在我们整个orbslam3里面,它其实在很多地方需要用到像什么ba,像什么go2啊,这些优化方面的一个方法,然后我们这个go2呢,
它就包含了一些我们这个图跟我们这个数学飞线性优化的一些算法在里面,我们,所以说这个第三方库我们会用到dbow2sophosg2o,好,那么这个vacabulary就是我们放的orbs点,我们orbs点在什么,比方说在哪一地方用到,用的最多的地方是吧,像我们这个slam这个回双检测,是吧,我要确定我的
这个相机,或者说我的机器人是否到达过我当前属在的一个位置,需要通过我们这个orbs这个磁点去进行一个
匹配,进行一个搜索,来确定,另外在我们那个tracking这个线程里面,有一个是假如说我们最终失败了,我们要重定位,那么这个时候也会用到这个我们orbs这个磁点去进行一个
特征匹配,还有一个进行一个重定位,好,那么我们看一下,就是我们在orbslam3这个整个代码,我们要执行的时候,比方说我用弹幕双目,或者说我们弹幕双目RGBD和我们IU进行一个结合,是吧,我们需要去跑其中的某种传感器的这个代码,那么我们首先要怎么样,我们跑代码的时候,我们肯定要对我们这个整个系统进行一个数字化,是吧,好,我们看一下我们这个数字化,
其实是从我们那个systemcc这个文件开始的,这个systemcc就是在我们那个src这个source这个原文件里面,是吧,它对应的那个头文件呢,是吧,就是我们system.h我们可以看一下,在我们system.h里面,我们可以看一下它的,这是我们这个代码里面包裹了几个头,可以看,这个是tracking,是吧,tracking.h,什么,这个是我们跟踪线程的一个头文件,
好,我们再看一下,我们这边是不是有个local mapping,这个local mapping是什么呢,局部建图,这个就是我们局部建图的一个,一个这个线程,还有什么,接下来我们有什么,有个币环和那个地图合并,是吧,这样一个线程,这三大的主要线程,然后呢,这个看到没有,也在我们那个system这个.h里面,就是说我们system.h里面,它在
执行我们system.cc文件的时候,它需要调用tracking,还什么,local mapping,还有什么,还有我们这个nope closing,就是说我们这个system.h,以及system.cc,是吧,就是我们那个system这个文件,它就是我们那个出入化的一个代码的一个入口,就是说,相当于就是说我在运行所有代码的时候tracking,是吧,local mapping,还有nope closing都会用到,
让我们再看一下其他的这些是什么意思,我们看一下frame draw,我们画帧,是吧,就是说,因为我们就在我们ordis name这个,这个各线程当中,我们地图它是需要,是吧,画出来,比方我们建图这个会用的,然后这个artnus,artnus是什么,artnus是我们之前上过了,artnus是什么,输入我们的这个多线程,也不是多地图系统,就是说我们多地图,就是这个artnus,然后呢,它的这个具体的
定义跟构建方法,就是在我们这个artnus那个.cc文件里面,也是在,这些基本上都在我们source里面,source,都在我们source,都在我们这个include,点h,这些都在include里面,对应的cc都是放在source文件夹里面,好,我们再看一下keyframe database这个关键帧的什么,数据库,就是说我们这个关键帧它的构建,它的数据
格式,都在我们这个里面,frame,keyframe,database,这个.cc文件里面,对,这是它的头文件,好,我们orb vocabulary,这个我们orb的这些词点啊,都在我们这个,都在它的头文件是这个,然后对应的也是orb vocabulary.cc这个里面,
然后这个variant.h,这个variant这个代码吧,就是.cc代码,它就是对于我们看到的这个界面,我们课程上,或者大家自己运行orb slam3这个代码的时候,大家看到的这个界面,它的这个箭图啊,都是我们那个variant,这个我们对应的代码去实施的,
然后呢,我们这个在我们这个orb slam3里面,它其实就是说,我们单目,双目,rgbd,它会跟什么,跟我们这个imu进行一个结合,那么这个imu它的那个种,它的那个定义的数据格式,它的一些各种函数,还有那方法在哪里呢,就在我们那个imu types,这样对应那个代码里面,
另外还有我们这个里面需要有一些参数的配置,还有一些像什么结构,我们在用的功能中会采用到的,那么呢,在我们那个setting,对应这个代码里面,
好,这就是我们这个system.h这个文件里面包含的一些我们的一些主要的一些什么,主要的一些代码的那个模块,
好,那么我们接下来看一下,就是我们那个system.cc它包括哪些内容,我们可以看一下,好,这个代码就在我们那个system.h文件里面可以看到这些部分它的一个定义,
然后另外在system.h.cc它都能看到,比如说我们看第一个,首先它这个函数里面这个参数有什么,有一个什么strain这样的一种格式,有个strain,Voc,fair,是吧,这个是什么,这个是对应我们那个磁带,vrcabular,是吧,vrcabular,fair就是我们对应的一个,它是什么样,它是一个,是个strain,是吧,字不串的一种格式的,是吧,就是这个对应我们那个磁带文件的它的一个路径,
好,第二个呢,是我们那个strain,setting,fair,它对于什么,它对于我们那个各种这种配置文件的一个路径,然后这个sensor呢,sensor它定义的一个e-sensor这样的一个传感器一个类型,它这个类型代表什么呢,其实就是代表我们这六种的这种传感器的输入,单目,双目,rgbd以及我们这三种传感器跟我们imu集合,获得这六种传感器的输入,
一个类型,就是我们在代码实际操作的时候,我们会有一个if选择函数,就是说我,就是说首先要判断一下我的那个输入的这个传感器,是吧,我输入这个传感器,输入传感器,它到底是哪一种传感器,然后呢,它通过先把我们传感器确定之后呢,它然后进行对应的代码的一个选择,然后一个执行,好,那么接下来还有一个就是我们那个,
那个b,那个use,value,就是说这个就是一个布尔形的,好,布尔形它不论是true,它代表什么呢,它代表就是说是否使用我们可视化界面,也就是我们看到的这个运行的这个实时的这个效果图,是吧,如果说你把它支撑force的话,那么它最后生成的只是输出我们那个路径的一个结果,
对,它就看不到这个实时的一个那个运行的图像了,好,然后另外插一句吧,就是我们在学习科学群里面有个同学也问到,就是说他用他的这个远程服务器为什么,就是说orb它没有运行起来,其实它是在运行的,只是说它这个远程可能在这个显示方面可能存在一些问题,最后他发现
它其实是运行的,就是说它最后它的那个我们相机的那个轨迹,还有我们那个关键帧的轨迹,它其实最终那个ts5键它是有生成的,对,就是说,其实就是说我们是吧,我们这个效果实时图,它可以不用显示,就是说不用显示,其实我们orb slam也在运行,是吧,最终为什么,它会成功的去输出我们那个相机位置,是吧,它的那个路径,这个轨迹,然后另外还有我们关键帧的轨迹都会输出来,表示什么,
表示我们orb slam3,它这个系统,它已经在正确运行了,对,好,那么我们这个unit frame,这个是什么,表示我们初速化的一个帧,我们这个id,我们初速化这个帧,我们说是什么,说为0,对,好,那么接下来的最后一个是什么,我们那个system这个构图函数里面是什么,
它就是那个strand sequence,它是什么,它是一个四步串,它表达的是什么,表达我们那个序列名,就是说我们在那个线程,这个跟踪线程和那个局部线程里面,我们会有一系列的这个,
那个关键图像帧,关键帧的它那些串,是吧,我们类似于把它看成一个序列,是吧,它的这种输入,它表达这样一个意思,好,那么我们看一下,
这是我们这个原来这个ORB,你们背着我们看一下这个system,它其实什么作用,initialize the slam system,就是我们要促化我们什么,我们那个Slam这个系统,是吧,
initialize local mapping,就是它要发起这个什么局部线图,另外还有什么node closing and value threads,就是说局部线程,然后我们闭环检测,还有什么,还有我们那个试图的这个线程,
就是说其实我们这个促化这个Slam的时候,其实它也包括什么,包括我们tracking,只是说它这个注释里面可能没写,但是我们真正看代码的时候,它什么tracking,还有什么,还有node mapping,还有node closing,是吧,这个node closing,它这个线程包括我们这个论文里面对应的,就是我们这个闭环和什么,和我们地图合并这样一个的线程,对,好,
那接下来我们继续往下走,好,那么我们要知道我们这个ORB slam 3吧,就是说它的这个出手函数,c term,是吧,我们那个四个点,然后c term,好,它的这样一个出手函数呢,它主要完成什么样的一个工作呢?
首先在这里,我们先从这个我们代码的这个逻辑上去讲解,待会呢,第二节课,也就是我们这个PG讲完之后,我们第二次课,当然今天都一起讲了这两次课,会根据我们这个具体的一个代码去讲代码里面它是怎么样实现的,
所以这个,首先我们这一块我们先讲一下我们这个代码逻辑,它是主要是执行到哪些步骤,好,我们看一下第一步,我们那个c term,四个方法,然后c term,是吧,它的这样一个执行到哪些呢?
首先我们第一步,要检查SLAM系统的什么,传感器输入化类型,就是说我们要去判断我们那个sensor,我们到底是用哪一个sensor,是吧,我们有六种,刚才也提到了,单目双目RGBD以及它们与之对应的与IMU的结合,我们有六种这种,我们这种传感器的一个类型,我们有六种这个类型,
好,那么我们我们检查sensor之后呢,我们第二步要怎么操作呢,就是在我们那个c term这个函数里面,我们在我们这个函数里面,第二步我们要检查我们传感器配置文件,其实对于我们传感器配置文件其实是比较保护的,
一个包括我们那个相机的内插,其实主要是我们相机内插,比方说像它的那个xy轴上的一些焦距啊,以及像它的一些我们那个光芯的什么,光芯的一个屏一下是吧,那个cy,fx,fx,还有fy,它这样一个焦距不同方向的,
好,这个需要我们用的是什么,strain settings fill,这样的一个这样一个函数,
好,然后接着呢我们要实力化OLB辞典,就加在我们这个OLB辞典,因为我们在这个tracking这一步的时候,我们首先有两种情况去解决定位,
首先我们通过最后一阵去做重定位,但是如果说我们重定位失败呢,我们需要去什么,去我们去查,去要匹配,去进行一个重定位,那么这个时候需要用到我们这个特征匹配,那么就具体要用到我们OLB辞典,
好,第四步,根据我们这个OLB辞典实力对象,我们要创建什么,创建我们关键帧database,就是我们要设计我们这个关键帧的它的一个数据结构,对,在我们这个关键帧database里面,好,我们创建了这个关键帧之后呢,接着我们要构造一个地图系统,因为我们在OLB slam3里面,它采用的是那个artnus这个地图系统,是吧,
它这个artnus其实两个目的,一个目的就是说在于我们这个在回还的那部分会用到,另外一部分就是在我们这个重定位的时候,因为对于我们这个传统这个OLB slam3,如果说我们比方说我们对着一个白墙的时候,假如说我们对着白墙,它就没有特征了,那么它重定位就失败了,那么这个时候我们常见的时候可能就是手动,我要去用手移动相机去找到一个比较好的特征点,比较丰富的这个,
那个图像帧,也就是我们要去然后重新实施重定位,但是呢,这个它其实是吧,需要我们人工操作,那么我们希望我们这个重定位是很智能的,让它自己能够去找到一些比较好的一个特征,那么是吧,这个我们就用artnus,artnus它有个active map,就是我们活动地图,是吧,这样一个概念,这样就能够去解决我们,需要手动去找到一个比较好的特征的这个图像帧去做重定位,
就是将我们这个手动的,如果我们重定位失败之后,将手动改成我们自动,对,就解决这样一个问题,然后电脑部我们就要对我们imu处置化,如果说我们这个,如果我们采用的传法系,如果它不是纯视觉的,它如果加入这个imu的这个配置的话,那么我们要对imu这个进行一个处置化的一个设置,好,这个代码里面会具体会有一个应付函数,会进行一个判断的,
好,我们第七步呢,就是说我们要利用那个artnus去创建draw,就说我们要去画,画什么,画我们这个,一个是我们那个关键帧framedraw,还有什么mapdraw,就是我们关键帧,我们去需要去把它那个,应该来说就画,其实就要表述出来嘛,另外还有什么,我们那个地图也要表述出来,好,
那么呢,好,大家可以看到,从一到七,其实相当于我们就是要把一些像什么传感器啊,像我们orb磁点啊,以及像说什么我们关键帧啊,我们地图系统啊,还有imu处置化呢,还有什么,还有我们这个怎么去构建frame,怎么去构建这个map,把它这些所有的一到七相当于就是,我把这些东西所有都要准备好,是吧,因为我们这个三个线程tracking、local mapping还有
nope closing,是吧,它都要会用到我们这个一到七这一部分的一些,我们预先要准备好的一些函数,是吧,一些功能,好,那么我们第八就开始怎么样,tracking的线程,我们要触发tracking的线程呢,就我们tracking主要做什么,我们tracking其实主要解决两个问题,一个是什么,重定位,就是我相机如果丢了之后,我要把它重定位,或者说最开始的时候,我需要重定位去把整个系统跑起来,重定位,然后后面建图,
然后回还,是吧,就是解决一个重定位,还有什么,还有一个就是我们要给我们nope mapping关键帧,好,它就这两个功能,好,那么我们在输出化之后呢,我们输出化tracking之后,我们要输出化第二个,我们就局部建图这个local mapping这个线程,是吧,那么那个local mapping把它输出化之后呢,我们继续第三个线程nope closing线程,听说在我们代码里面,它的函数名是叫nope closing,
其实它就对应我们这个论文里面的这个nope closing and mapping merging这个线程,就是我们回还,是吧,检测跟什么,跟我们地图合并,是吧,就在这样一个线程里面,好,那么呢,我们这三个线程输出化之后呢,我们最后是不是我们看到有个效果图,我们需要把那个可输化线程这个variable,是吧,这个线程它其实在不对应我们算法的线程,我们算法只有三个,
三个线程,主要是这三个线程,我们这个可输化线程呢,其实主要为了建图,这个是在我们代码成绩的一个线程,算法成绩它不属于一个线程,好,那么最后呢,我们要将我们上述这些对象,就是我们所有的这些,就是我们这些出来的一些对应的结构吧,要对象指人,把它做成一个指人,然后呢,传到我们那个输出线程,方便我们输出共享,就是说因为我们在这些共同会产生一系列的中间比较重要的一个
数据,我们在后续的这个系统运行的过程中,它会实时的去使用到一些数据,所以我们要将我们一些那个出来的结果,把它做一个对象指人,然后呢,达到我们那个数据共享,整个系统数据共享的这样一个目的,对,这就是我们这个system它这样一个函数,它要执行的一些功能,好,也就是这十二个。
好,它的,我从一到十二号,这样它其实是一个迅速执行,我们是一步步的执行过来的,好,那么我们看一下,就是说我们首先我们那个system这个函数里面,好,我们看一下,是吧,首先它有一个我们那个那个我们此代的这个这个路径的路径需要输入,还有什么,还有我们配置文件的路径,还有什么,我们sensor就是我们这个传感器,它是什么样的传感器,是吧,
它有三目双目RGBD,还是说跟它们这每一种,是吧,跟我们MPU结合,第二个就是说我们这个是否要显示我们这个效果的运行图,最后一个就是什么,最后一个我们那个初始针,好,那么我们看第一步,我们第一步要什么,要做一个检查slap系统,传感器是化模型,需要用sensor,好,其实我们这个一到十二就是刚才总结的,就是说那十二的工具,我们看一下它每一个函数对应的哪一个,我们在damp里面,
有一个衣服,是吧,我们这个要判断一下,比方说我们这个例子里面是判断它是否是弹幕,它有衣服语句去完成我们这样一个功能,好,那么第二个就是检查我们传感器配置文件,也就是我们相机的参数需要用到StringSettingsFail,然后我们看一下这个StringSettingsFail,它函数形式是这样的,我们看一下,它的里面包括什么,我们那个SettingsFail,是吧,还有一个什么,它的一个路径,还有什么,还有我们它这个文件存储,
它是否是能读的,好,我们第三个就是实例化我们ORB辞典,然后并加载ORB辞典,我们看一下,我们这个MPVecabulary,好,这样一个变量,它其实就是说,就是我们要建一个ORBVecabulary,这样一个变量的这样一个过程,好,然后另外就是说,是否要加载它,是吧,我是否要加载我们这个ORB辞典,对,就在代码里面,它通过这种
对应着这样一段的一个代码,好,第四步就是根据ORB辞典实例化创建关键的Database,我们看一下,我们Database是哪个函数来创建的,好,这个是我们MPKeyframeDatabase,是吧,好,这个是我们这个
ORB辞典,我们要实例化,好,我们实例化,用的哪个函数,用这个KeyframeDatabase,好,这样,通过这样的就能够去创建我们的这个ORB的这个关键帧的一个什么Database,好,那么到了第五步,我们第五步就要创建Artness,也就是我们这个多地图系统,好,这个我们看一下,这个NewArtness,看到没有,这个Artness其实都是不同的类,我们它不同的类,不同的一个函数功能,我们通过这样NewArtness,
去构建了我们这个多地图系统,好,第六步,就是我们这个IMU传感器,它速度化设置,就是说我们,我们在学校检测,就是说我们,是吧,这个RGB,单目双模RGBD,它是否用到那个IMU,那么我们,这个呢,就首先我们要判断一下,就是说我们要判断一下我们这个UNIF影剧,判断一下我们这个里面是否用到了有IMU,是否有IMU,好,那么如果有的话,我们就怎么样,
把我们这个设置为true,这个mb is inertia,就是说是否有我们的惯性单元,好,就设为true,如果有,我们后面会执行一些跟,就是说我们视约跟IMU融合的一些,一些函数的功能,会去进行一个调用,好,那么我们第七步,就是说我们用Artness创建draw,也就是说我们要在Artness去什么,去构建我们那个图像帧,还有什么,
构建我们那个地图,好,它通过怎么样,这个是我们这个图像,这个draw,mp draw,然后好,new,然后frame draw,mp Artness,看见没有,这个就构建出我们那个frame draw,这样一个,我们这个变量说来的,好,第二步就是我们构建我们mp map draw,它就是new map draw,这个对应我们这个代码里面,就是这两句,好,
那么到第八步,就是说,好,我们一到七是什么,是要准备我们这个,开始执行我们这个三个主要现成的,好,那么我们准备好之后呢,就是说,是吧,从我们那个传感器,然后以及我们这个像图像帧,还有什么地图,以及什么,以及我们刚才的想到一些变量,我们首先要准备好,像ob10.这些东西准备好,然后再开始我们出的话,我们就tracking,好,看一下我们这个tracking对应的代码段是哪一个,
tracker,然后new tracking,好,我们看一下,它里面有什么,是不是,我们上面定义到像什么词点,然后我们那个frame draw,还有什么map draw,以及什么多地图Artness,还有什么,我们图像keyframe database,我们图像帧的那个数据库,还有什么,还有我们settings,fail,还有我们那个设置文件的录音,还有什么,还有就是说我们这个传感器的一个类型是什么样的传感器,还有什么,
就是我们那个图像的训练,是吧,这些东西是它的一个输入,就是说我们要执行这个tracking现成,然后它就包括这样一系列的一个输入在里面去,对,这个在我们代码里面都有体现,好,
然后第九步的就是说,我们要出的话,局部nucle mapping这个现成,然后要去加的这个现成,好,我们看一下我们怎么样去,去,去那个在代码里面,好,你看map,nucle mapping,
好,新建一个nucle mapping这个现成,好,它在里面有一系列的一些什么,比方说我们要读地图,还有什么,还要我们传感器,是吧,我们传感器,
首先我们要判断一下它是单目,是吧,它是单目,这个这个这个是不是单目,这个是什么,imu跟单目融合,然后这个是什么,imu跟单目,
对,imu单目或者说imu是双目,然后我们同样训练,就是它里面有这样一些的一个变量的一个输入,好,
那么呢,然后建立new thread这个现成,是吧,我们这个现成是ORB slam3的这个局部建图,好,然后另外它这个是局部地图,好,这是我们这个现成的一个输入,好,
那么这样相当于说我们建了一个一个一个现成的这样一个功能呢,局部建图现成就是这样构建的,
好,另外第十部分就是说我们要输入的话我们那个币环,那个币环和我们地图合并,好,我们看一下,是吧,新建一个币环跟地图合并,
好,它包括什么,一个是我们ATNA多地图,还有什么关键针的这个酷,还有什么我们这个磁带,另外还有什么,
还要我们判断我们这个sensor它是什么样的传感器,好,那么我们new thread,好,把这个我们这个币环跟地图合并这样一个现成把它构建出来,
好,第十一步就是说我们要,就是说我们各个现成把它这个建立好了之后,我们要进行一个可视化,好,要进行一个可视化,
那么我们那个可视化呢,好,我们有个判断,就是b,user a variable,我们是否要去可视化我们这个现成,好,我们看一下它里面包括什么,
首先我们要新建一个我们这个可视化的这样一个这个功能出来,好,然后将这个功能呢,将这个功能什么,将这个功能要用一个性能去把它构建出来,好,
那么呢,我们这个里面包括哪几分,一个是track,就是我们那个tracking这个现成,还有什么,币环的现成,是吧,
把它的这个tracking跟那个币环的这些功能把它都怎么样,都要送到我们这个,这个我们那个,这个可视化这个现成里面去显示,好,
好,最后呢,我们要将算数实力化的对象指针,就是说把它做成指针,传到我的其他现成,方便我们数据共享,
就是说我们这整个系统在使用过程中,其实像很多这个,比方说我们这个tracking它产生的这个Keyframe关键帧要给到我们Lukman,
然后Lukman它最后也会输出一些关键帧,像或者说像一些基础点,它会给到我们币环,是吧,
就是说我们这个三个线它其实之间它是有数据交换共享的这样的过程,好,那么呢,我们这样一个功能呢,
它其实就相当于就是说我们要把我们那个tracking这个现成里面这些,把它是吧,把它送到我们,
比方说一个是我们那个箭图,另外一个币环检测,是吧,那么呢,同理我们这个局部箭图呢,
要送到我们tracking,一些数据要送到我们tracking里面这个现成,然后呢,另外也送到我们币环与地图合并这个现成,
同样我们这个币环跟地图合并这里面的一些,是吧,一些那个数据我们要送到这个tracking现成和那个什么local mapping这个现成里面去,对,
所以说,所以说它代码体验在这三部分就相互的去给对方,就是去给数据,对,也就是说我们给它传我们那个对象的一个指针,对,在代码实现上是这样的。
好,刚才讲到呢,就是说我们orbslam3的数字化,其实它整个代码都在我们那个system.h和system.cc这个代码里面,
它主要是做什么呢,主要是完成了我们主要12个功能,首先我们判断什么,判断我,首先我们要做一个预处理,
比方说在我们三个系统开始之前做一个预处理,像我们这个要判断我们这个system,就是我们传感器,是吧,
是吧,单目双目RGBD以及跟我们IMU分别去做融合的,这六种我们首先开始要判断,哎呦,我传感器是什么样的,第二部分我们要准备什么,准备我们的orbs点,
还有准备什么我们那个关键图像帧frame,还有那个什么map他们的一些数据格式,好,另外还有一些其他的相关东西准备吧,
就在一到七步里面我们去完成这样一个准备的功能,好,那么,好,接下来我们三部就是分别去构建什么,我们tracking线程,那个loop mapping线程,还有什么,还有我们那个loop closing这样一个三个线程,是吧,让我们这三个线程进行一个触发,最后呢,为了去实现我们这个效果的那个实时显示,那么我们在代码层面也构建了一个线程,也就是我们那个value,
这样一个线程,可触发线程,然后呢,这所有的这些做完之后,我们最后一步就是说,我们要将我们上述这些,我们那个实例吧,比方说我们这三个线程把它进行一个对象指针,实例的对象进行一个指针,然后呢,分别传给我们其他两个线程,就是说这样已达到我们那个,我们数据实施,数据共享的这样一个目的,这个就是我们orbs LMP3的一个目的,
出入化的这样一个过程,好,那么接下来我们讲讲就是我们传感器输入的这个模块,其实刚才也在讲这个出入化的过程,其实我也大致给大家讲到了,就是说我们首先要判断,判断我们这个传感器,它的这个,呃,是哪种传感器,是吧,通过判断哪种传感器,我们才能执行后续的一些具体的代码操作了,好,我们可以看一下我们首先,首先在我们这个System.cc里面,
它同样在System.cc里面,这不代码,就是说它主要我们有六种传感器,是吧,比方举个例子,首先第一个就是对于我们单目,第二个就是双目,第三个就是RGBD,然后以及他们这三种分别与IMU,是吧,结合的这样的一个,嗯,就构成了六种,好,我们看一下我们这个,它的这样一个函数里面,它的这个参数是怎么样的,对于我们这个track,
这个tuner,这个是单目的,我们看一下它输入是什么,首先我们要输入一个什么,image,我们图像,另外还有一个什么,还有一个时间戳,就是我们这什么时候喂到我们这个track,tuner,这样一个函数里面去的,好,接着就是什么,大家看到这个IMU point,这个其实就定了我们这个IMU,就是说我们这个如果用到IMU,那我们这一部分是有输入的,好,最后一个就是strainfair,它,它所,目前
给的是一个空,好,那么对于我们双目,双目或者双目惯性是吧,好,这个是image left,就是我们左图像,好,image right,右图像,然后这个是time step,这个是我们时间戳,好,这个同样就是,呃,就是我们IMU,这个是IMU的,好,另外同样有个fair name,好,第三个就是我们那个RGBD的,我们看一下track RGBD,它里面,首先我们是image,
是吧,我们肯定有输入图像,好,那么另外还有什么depth map,就是我们深度图,然后另外时间戳,另外IMU,另外还有个fair name,这个其实这三个函数大同小异,只是我们可能就是前两项不一样吧,呃,不是,可能就是对于图像这一块不一样,我们大部分只有一张图,然后那个双目的是要image left和那个image right,然后对于我们那个RGB呢,有什么image,还有什么depth map,对,他们,呃,就是说他们这些,
呃,整个函数下来,它其实就是代码写的还是挺规则的,也是对于大家就是说怎么学习,怎么使用CIA,也是一个比较好的一个范围的,好,那么我们看一下,就是我们这个传感器输入模块,就是说它对我们不同数据的一个处理,就是说它其实对应的我们三个主要的函数,它在System,System里面就是sofas,sofas是我们一个拟代数库,就是它是一个拟代数CIA的库,就是它,呃,它通过把我们那个
呃,可以将我们那个相机的位置啊,旋转频应啊,这些都通过拟代数库来表达,对,好,然后呢,它在分别在我们这个Track,Molocular,TrackStory,TrackRGBD这三个函数里面去,我们看一下,就是说我们这个传感器输入它是怎么样做一个执行的,好,首先第一步我们要检查我们Snap它的这个传感器,它的一个类型,是吧,首先你看我们接着相遇,我们衣服已经有,
我们要去判断它,我们看一下这个TrackStory,我们这个是判断是否是我们那个双目的,这个是判断什么,是否是RGBD,这个判断是否是我们那个单目的,就是说它对应的我们代码,它是这样的,好,第二我们要检查我们定位的模式,是吧,检查我们是否打开我们这个定位,好,好,我们看一下,就是说如果说我们这个打开了我们这个主动建图定位的这样一个模式,好,
执行这样下面的一系列的一个操作,好,如果说,是吧,如果说我们这个关闭了我们这个定位模式,然后呢,它就进行下面一期稍后我们可以看一下,是吧,它的,比方说这个,这一个它将来就是说我们只做一个跟踪,好,这个好,我们那个局务地图,然后这个是什么,这个就是我们这个,就是说关闭我们定位的这个模式,
把它制成force,好,这个是检查这个定位的模式,好,那我们第三步就要什么,第三步就是检查我们重置的状态,就是说我们track现成,或者说我们active map,检查我们重置的一个状态,好,我们看一下,是吧,它有一个衣服判断语句,好,然后呢,就是说,就是说它将我们这个track现成做了一个重置,然后呢,重用之后把它制force,然后这个是什么,这个是我们,
是否重置我们这个主动建图,是吧,因为在我们track里面为了这个重定位,我们需要什么,有两种形式,一个就是我们track通过最后一针做一个重定位,如果说我们重定位失败,那么我们就要去怎么样,就要去用这个artnash去做一个重定位,artnash使用的,使用的其实就是我们active map,所以这一步其实功能就是两步,一个就是要么用我们这个track,
这个现成里面用最后一针去做一个重定位,就是我们track自己做重定位,另外要么就是用我们这个artnash,也就是说我们active map去做一个重定位,是吧,大家可以看一下,如果说我们是吧,reset好,那么我们就是重定位,那么首先我们默认去用什么,用track做一个重定位,那如果说我们不是用,那如果我们相当于就是说我们这个不是用我们这个track里面这个通过最后一针,
或者说全局重定位的话,这两种就是我们orbslam2或者orbslam1里面这个重定位功能的话,那么我们就用什么,用我们这个artnash这样一个重定位的功能,对我们地图,对我们那个相机位做一个重定位,对,这一步就实验这样一个功能,也就是说本质上就是说它要解决一个重定位的一个功能,好,接下来我们就要判断一下,就是说是不是imu,如果用到imu是吧,用到imu重定位的话,
那么我们后面这一切的操作就是要对我们imu进行一个操作,要对imu进行一个操作,好,那么第五个也是我们tracking,好,我们将上述的就是我们将这个我们这个重定位做了之后呢,就是我们那个我们imu判断它的那个是否有imu这个传感器,接下来就是我们tracking现成的一个计算我们那个当权位置呢,
就是要完成我们这个,我们这个orbslam3这个,这个这个流程图里面的,论文流程图里面就是那个trackmap,trackmap这样一个功能,跟踪局部地图,好,我们看对于我们这个双目来说,它的那个tcw也就是我们那个,这个t就是transform就是我们那个,就是变换,是吧,我们相机的一些变换,好,那么它包括什么,包括一个频异跟旋转,频异跟旋转,
好,那么我们这个track它通过这样一个grab获得什么图像的,获得那个立体图像的什么一些,通过这样一个函数,好,通过这样一个函数,对于我们立体图上就是grabimage,story这样一个函数去获得什么,获得我们这个相机的一个位置,好,那么对于rgb来说呢,它就是通过是吧,同样的grabimage,rgbd,好,通过这样我们可以看一下,
我们这个双目输入是怎么样,lapt,图像,右图像,然后时间戳,还有那个fanlamp,好,那我们那个rgb呢,它输入是怎么样的,图像,是吧,同样深度,还有什么时间戳,还有什么fanlamp,好,对于我们那个单目来说,好,我们同样的grabimage,monocular,是吧,图像,还有什么时间戳,还有我们那个fanlamp,好,我们这三个呢,都在我们那个tracking.cc文件里面去,就是说我们现在讲到所有的这些啊,
我们这个setum那个.cc文件里面的,就说setum.cc它主要做两个,一个是输入化,是吧,一个是我们那个整个系统输入化,另外还有就是我们传感器这个输入,传感器这个输入这个模块,它要执行一个代码,都在我们这个setum.cc里面,好,点c里面,好,然后呢,我们如果把这些步骤都做完了,那么就到了我们tracking.cc,我们tracking.cc它其实主要就是说怎么样呢,
就是说通过我们这三行路获得什么,获得我们这个位置,或者相机位置,这个就是tracking要解决的一个问题,好,那么最后呢,我们就要把所有的进行更新,因为我们这个有一个优化运行的结果嘛,最后我们就把什么tracking的状态,还有我们那个tracking里面那个map point,还有什么tracking里面那个关键点,是吧,全都做一个更新,因为我们上面做了一些运设嘛,最后我们要把所有的参数跟那个数据做一个更新,
那么就是说我们刚才在代码执行功能,我刚才也就是说,说到了主动讲了这三个这个函数,我们要完成什么功能呢,我们要完成我们这个tcw,也就是我们那个位置,位置包括旋转跟平移,我们要,我们那个tracking其实就是说要解决就是这个旋转跟平移,也就是说我们要确定它的一个位置,好,那么这几个位置呢,都在我们tracking现成,也就是我们接下来讲的,
就是我们那个tracking这个现成,它主要是要解决什么样一个功能,好,那么我们现在讲一下tracking现成那个子模块,好,我们看一下,上面的都是,是吧,我刚才讲了,就是track,monocular,track,story,track,rgbd,是吧,这样的几个函数都在我们那个ctime.cc文件里面,好,那么它主要完成两个工作,刚才其实讲了,首先第一个我们要生成我们的frame,
关键帧是吧,要生成关键帧,好,那么呢,根据那个frame我们调用那个track,这个track函数呢,这个就是好,中的这个grave image,grave,monocular,grave,rgbd,进行我们增加的这个位置估计,其实就是刚才这个,就是刚才上一篇给大家讲的,就是我们grave image,story,是吧,我们左边图像,右边图像,
实验戳,还有phenome,然后呢,我们对于这个grave image,rgbd呢,是什么,rgbd图像,然后它的深度,还有实验戳,以及它的那个phenome,它的,还有对于我们那个monocular单目的,好,它的是什么,图像,实验戳,phenome,好,
那我们看一下,就是说,对于我们这样的三个,其实大家可以看到,它的这个代码写的还是蛮工整的,就是说,它的这个输入都是根据它的特点是一亿堆的,所以说,我们这样一个过程其实都是大同小异的,就是说我们输入的过程其实大同小异的,
首先我们要输入一个诊,输入之后呢,我们要去处置化,做哪一个工作呢,首先我们要怎么样,我们ORB要去提取特征,通过调用extract ORB这样去,去,去抽取特征,然后呢,我们特征点要做一个效验,它用什么,undistort keypoints这样一个函数去,去执行这样的功能,另外我们要估计深度,computer stereo mesh,还有computer stereo from rgbd,
好,就我们弹幕,是吧,弹幕必须要连连续两帧才能去计算深度,它通过单帧它是算不出来的,当然通过深度学学方法,现在有的可能学术研究上有,但是目前吧,传统方案它基于多数的几何,我们必须至少两帧才能算出来,好,我们弹幕可以直接算我们那个深度,好,我们这个rgbd也是通过可以直接算深度,好,第四步就是怎么样,第四步就是
就是我们特征网格化通过assign features to grade这样一个函数去执行,好,接着就是我们对我们这个图像提取rb特征之后呢,我们好,去要去调用我们那个track这个位置估计呢,那么我们track其实对应的函数其实就是我们讲到了这三个,好,那么接下来我们要进到这三个函数的它的一个使用方法,它的这样流程里面去,对,就这三个就是要执行我们那个track这样一个功能,
首先它有三步,第一个是我们要,当然我们要出手的话是吧,把我们之前一些数据把它要拿过来,然后正经估计,就是说我们要去怎么样通过我们这个这样三个函数去得到我们项流位置,这就是我们正经估计,另外最后一步就是说我们要去track这个线程,还要去什么输出我们关键程,给到我们什么第二个线程,局部建筑线程使用,好,我们接下来就要进入到我们那个track这个线程,
它是怎么样去进行一个位置估计的,好,我们看一下,就是这就是它的一个解构图,好,我们看一下就是track线程首先,好,判断是否需要等待,这个是我们相当于预处理的过程,好,检查同样,其实跟我们之前预处理是一样的,就是因为这个到了我们实际上好,那么我们要检查imu是吧,它的数据是否正常,就是我们要检查imu这个数据,好,那么检查之后呢,我们就是数据质量,另外我们要检查我们这个
数据,也就是对我们那个图像真的一个检查,那么我们开始要做增加一个tracking,好,那么接下来,好,这是增加tracking之后呢,我们要到这一步,就是试过输出化,如果没有输出化,我们要进行一个输出化,输出化之后呢,我们要对它相机进行一个选择是单目还是双目,好,那么如果是的话,如果双目,我们就双目输出化,单目单目输出化,最后会怎么样,获得我们初始的一个状态,好,如果我们输出状态,如果说获取成功了,好,那么
我们就通过,其实这个只有一张图才更新,其实这个就对于我们这个论文里面,这个流程图里面,就是from last frame,就通过最后一针去怎么样,去获得我们相机位置重新位,好,如果我们失败,那我们就相对什么,相当于我们那个tracking丢失了,我们就退出来,通过其他方向做一个相机的重新位,好,最后到后面去了,然后保存当前的
那个相机位置,相当于这一步相当于我们也是做一个重新位的一个功能,好,它做一个重新位获取相机位置,好,那如果说它没有输出化成功,如果说我们输出化成功了,那么怎么样,我们就直接,我们就直接要tracking了,tracking后面的一些功能,首先我们要什么,定位模式,就是什么意思呢,就是说我们要是通过我们这个tracking,它就是tracking,
像Orbis 7.2他们有的这个tracking,比方说我们从最后一针,然后以及就是说我们通过Orbis匹配做重新位,还是说我们要根据什么,根据我们这个Atlas多地图系统做一个重新位,这个是吧,这个需要判断的,在这个地方我们用的是定位功能,好,然后我们要调用这个track位置,motion model或者说我们track reference key,
frame去进行一个这个增添的这个tracking这样一个功能实现,好,我们这个tracking做完了之后呢,我们相当于这一步,我们就实现一个重新位功能了,好,
重新位功能之后呢,我们接着要进行局部地图,我们局部地图呢,采用是包括两步,一个是定位加剑图下,我们调用是tracking local mapping,好,另外一种就是说定位模式加上定位成功状态,我们调用tracking local mapping,对,
其实两种情况,它其实都是最终去调用tracking local mapping,就跟踪局部建图这样一个功能,其实跟踪局部建图它其实主要处理的,也就是说我们这个地图点,我们要对地图点进行一个不同的筛选,达到一个定位的一个,其实它相当于优化我们重定位,对,其实这个局部地图它的一个重要重要就是说,我们对我们那个地图点进行一个优化,然后去怎么样,去优化我们这一步或者我们这个地图点,
到一个定位的一个结果去优化它,好,那么更新我们那个tracking的一个状态,如果说我们跟踪正常,如果是丢失了,我们就lost,如果说我们事业加密丢失,然后我们是吧,代码里会有这样一个,就状态一个更新吧,好,那么接下来就是说更新可视化窗口的内容,就是说我们这些,是吧,我们这个位置这些参数,最后输入结果之后,我们要反汇到,
那个value这个线程上面去,就可视化这个线程上去,好,整个做完之后,我们会得到一些关键帧,那么我们会将这些关键帧,是吧,把它给到我们什么,给到我们下一步,就是给到我们这个,我们第二个线程,就是局部建图这个线程好,接着我们再重新系统,就是说如果在没有imu情况下呢,我们这个丢失帧必须要大于等于5,然后最后就是更新我们last frame,
就去保证保存下我们这个相机的一个位置,整体上它的,可能我们这些很多这些细节,跟我们这个理论上不一致,因为我们这个ORB slam,说实话,它本身从理论上来说,可能它创新率不是很特别大,但是呢,它在工程上都属于一个很好的一个算法,就是说它在这些里面,它其实有很多一些员工经验,把一些嗯,根据经验设定的,
一些过程吧,把它加进去了,所以导致它的这个看起来中间过程比理论上要反锁一些,对,好,那么今天最后一部分来讲是tracking线程代码箱解,那么这个代码箱解呢,其实就是说,也就是我们今天的第二次课,我主要是通过我们这个代码的进行讲,就是我们在qt,我们通过qt create这样一个编辑器,去给大家,
去讲解我们每一部代码表是什么意思,然后它输出的是什么,完成的功能是怎么样,然后呢,就是说,可能有个同学是用viscode,当然也可以,然后呢,因为我用的是那个qt create,我也建议大家,如果,也可以试试这个qt create,当然这个无所谓,用什么编辑都可以,对,然后这次课我们就讲完了,接下来也是今天第二次课吧,就是说给大家就直接在我们的qt create,
编辑器上面去讲,详解我们这个tracking这样一个线程它具体的一个过程啊,那这一课我们就结束了,
