# EKF-SLAM 數學推導筆記 (Part 1)

> 本筆記整理 Kalman Filter 在 SLAM 中的數學基礎，從線性形式推導到 EKF 的 Jacobian 線性化。

---

## 1. SLAM 問題的本質

SLAM = Simultaneous Localization and Mapping（同時定位與建圖）

**核心問題**：
```
已知：
  - 控制指令 u_t（我下達了什麼命令）
  - 感測器觀測 z_t（我看到了什麼）

求解：
  - 機器人位姿 x_t（我在哪裡）
  - 地圖 m（環境長什麼樣）
```

---

## 2. 狀態方程與觀測方程

Kalman Filter 用兩個方程式描述系統：

### 狀態方程（State Equation / Motion Model）

```
x_t = A x_{t-1} + B u_t + w_t
```

| 符號 | 意義 | 說明 |
|------|------|------|
| `x_t` | 當前狀態 | 機器人位姿 + 地圖點位置 |
| `x_{t-1}` | 上一刻狀態 | |
| `A` | 狀態轉移矩陣 | 「什麼都不做時，狀態怎麼變化」 |
| `B` | 控制輸入矩陣 | 「控制指令『理論上』怎麼影響狀態」 |
| `u_t` | 控制指令 | 實際下達的命令（如：向前 1m） |
| `w_t` | 過程噪音 | 執行不完美（輪子打滑等），`w_t ~ N(0, Q)` |

**白話**：「根據上一刻的狀態 + 我的控制指令，預測現在應該在哪」

### 觀測方程（Observation Equation / Measurement Model）

```
z_t = H x_t + v_t
```

| 符號 | 意義 | 說明 |
|------|------|------|
| `z_t` | 觀測值 | 感測器實際量到的數據 |
| `H` | 觀測矩陣 | 「從狀態映射到感測器讀數」 |
| `x_t` | 當前狀態 | |
| `v_t` | 觀測噪音 | 感測器不完美，`v_t ~ N(0, R)` |

**白話**：「如果我在這個狀態，感測器『應該』看到什麼」

---

## 2.5 如何判斷 Sensor 該放「運動方程式」還是「觀測方程式」？

這是很多人困惑的點：為什麼 IMU 放運動方程式？GPS 放觀測方程式？

### 核心判斷法則

**問自己一個問題：這個 sensor 給的是「狀態本身」還是「狀態的變化」？**

| Sensor 給的資料 | 放哪裡 | 原因 |
|----------------|--------|------|
| **狀態本身**（直接告訴你「你在哪」）| 觀測方程式 | 可以直接與預測比較 |
| **狀態的變化**（告訴你「你怎麼動」）| 運動方程式 | 需要積分才能得到狀態 |

### 實際例子

假設狀態是「位置」：

| Sensor | 給什麼 | 放哪裡 | 說明 |
|--------|--------|--------|------|
| GPS | 位置 | 觀測 | 直接量測位置 |
| RTK-GPS | 位置（高精度）| 觀測 | 直接量測位置 |
| IMU | 加速度 | 運動 | 位置的二階導數，需要積分兩次 |
| 輪速計 | 速度 | 運動 | 位置的一階導數，需要積分 |
| LiDAR 定位 | 位置 | 觀測 | 透過點雲匹配得到位置 |
| Visual Odometry | 位移變化 | 運動 | 給的是「移動了多少」 |
| 磁力計 | 朝向角度 | 觀測 | 直接量測朝向狀態 |

### 為什麼不能反過來？

以 IMU + GPS 為例，如果反過來：

**GPS 當運動方程式？**
- GPS 只給位置，不給「位置怎麼變化」
- 無法建立動態模型 `x_t = f(x_{t-1}, u_t)`
- 而且 GPS 是 10Hz，中間 0.1 秒不知道發生什麼

**IMU 當觀測方程式？**
- IMU 給的是加速度
- 狀態是位置
- `加速度 = H × 位置` 這個關係不存在！
- H 矩陣設不出來

### 一句話總結

> **能直接「看到」狀態 → 觀測方程式**
> **描述狀態「怎麼變」 → 運動方程式**

這是由 **sensor 的物理意義** 決定的，不是隨便選的。

---

## 3. A、B、H 各自代表什麼？

### A：狀態轉移矩陣

**意義**：「如果什麼都不做，狀態會怎麼自然變化」

**例子**：等速運動的車
```
位置_新 = 位置_舊 + 速度 × Δt
速度_新 = 速度_舊（假設等速）

寫成矩陣：
[位置]     [1  Δt] [位置]
[速度]_t = [0   1] [速度]_{t-1}
           ↑
           這就是 A
```

### B：控制輸入矩陣

**意義**：「控制指令『理論上』會怎麼影響狀態」

**注意**：B 描述的是「理論影響」，不是實際結果

**例子**：
```
你踩油門（u_t = 加速度）
理論上：速度增加 = 加速度 × Δt

B = [0.5×Δt²]   （影響位置）
    [Δt    ]    （影響速度）
```

### u_t：實際的控制指令

就是你「實際下達」的命令，例如：「向前加速 2 m/s²」、「左轉 30°」

### H：觀測矩陣

**意義**：「從狀態映射到感測器讀數」

**例子**：GPS 只能量位置，不能量速度
```
狀態 = [位置, 速度]
GPS 讀數 = [位置]

H = [1  0]  ← 只取位置，忽略速度
```

### 兩個方程式在「對齊」什麼？

```
狀態方程：「根據上一刻 + 控制，我『預測』現在在哪」
觀測方程：「根據感測器，我『看到』自己在哪」

這兩個估計通常不一樣！
卡爾曼濾波的工作 = 把它們「加權平均」得到最佳估計
```

---

## 4. 為什麼卡爾曼濾波需要「線性形式」？

**卡爾曼濾波的數學推導有一個前提：所有方程式必須是線性的。**

為什麼？因為卡爾曼濾波的核心是「高斯分佈的傳遞」：

```
如果 x 是高斯分佈，經過線性變換 y = Ax + b
那麼 y 也是高斯分佈

但如果經過非線性變換 y = f(x)
y 就不再是高斯分佈了！
```

卡爾曼濾波的所有公式（預測、更新、計算增益）都假設狀態是高斯分佈。一旦不是高斯，這些公式就失效了。

**所以線性形式不是「選擇」，是「必須」。**

---

## 5. 問題來了：真實世界是非線性的！

上面的線性形式很美好，但真實世界不配合：

### 狀態方程的非線性

```
理想線性：x_t = A x_{t-1} + B u_t

實際情況（車子轉彎）：
  x_t = x_{t-1} + v × cos(θ) × Δt
  y_t = y_{t-1} + v × sin(θ) × Δt
  θ_t = θ_{t-1} + ω × Δt

  ↑ 有 cos、sin，不是線性的！
```

寫成一般形式：
```
x_t = f(x_{t-1}, u_t) + w_t
      ↑
      f 是非線性函數
```

### 觀測方程的非線性

```
理想線性：z_t = H x_t

實際情況（用相機看路標）：
  看到的角度 = arctan((landmark_y - robot_y) / (landmark_x - robot_x))
  看到的距離 = sqrt((landmark_x - robot_x)² + (landmark_y - robot_y)²)

  ↑ 有 arctan、sqrt，不是線性的！
```

寫成一般形式：
```
z_t = h(x_t) + v_t
      ↑
      h 是非線性函數
```

---

## 6. 解法：用 Jacobian 做「局部線性化」

既然卡爾曼濾波需要線性，而真實世界是非線性，怎麼辦？

**EKF 的核心想法：在「當前估計值附近」把非線性函數近似成線性**

這就是泰勒展開的一階近似：

```
f(x) ≈ f(x₀) + f'(x₀) × (x - x₀)
               ↑
               這個斜率就是 Jacobian
```

### F 矩陣（取代 A）

```
原本非線性：x_t = f(x_{t-1}, u_t)

線性化後：x_t ≈ f(x̂_{t-1}, u_t) + F × (x_{t-1} - x̂_{t-1})

其中 F = ∂f/∂x |_{x=x̂_{t-1}}  ← 對狀態的偏導數
```

**F 的意義**：「狀態的小變化，會怎麼影響下一刻的狀態」

### H 矩陣（重新定義）

```
原本非線性：z_t = h(x_t)

線性化後：z_t ≈ h(x̂_t) + H × (x_t - x̂_t)

其中 H = ∂h/∂x |_{x=x̂_t}  ← 對狀態的偏導數
```

**H 的意義**：「狀態的小變化，會怎麼影響觀測值」

---

## 7. 具體例子：2D 機器人

狀態：`x = [x, y, θ]`（位置 + 朝向）
控制：`u = [v, ω]`（線速度 + 角速度）

### 運動模型（非線性）

```
x_t = x_{t-1} + v × cos(θ) × Δt
y_t = y_{t-1} + v × sin(θ) × Δt
θ_t = θ_{t-1} + ω × Δt
```

### 計算 Jacobian F

```
F = ∂f/∂[x,y,θ] =
    [∂x_t/∂x  ∂x_t/∂y  ∂x_t/∂θ]   [1  0  -v×sin(θ)×Δt]
    [∂y_t/∂x  ∂y_t/∂y  ∂y_t/∂θ] = [0  1   v×cos(θ)×Δt]
    [∂θ_t/∂x  ∂θ_t/∂y  ∂θ_t/∂θ]   [0  0        1      ]
```

**解讀**：
- x 對 x 的影響是 1（自己影響自己）
- θ 對 x 的影響是 `-v×sin(θ)×Δt`（角度變化會影響 x 方向的移動）

---

## 8. 總結：線性 vs 非線性 vs Jacobian 的關係

```
┌─────────────────┐
│  理想世界        │  x_t = A x_{t-1} + B u_t
│  (線性)          │  z_t = H x_t
│  → 用標準 KF     │
└────────┬────────┘
         │ 但真實世界...
         ▼
┌─────────────────┐
│  真實世界        │  x_t = f(x_{t-1}, u_t)  ← 非線性
│  (非線性)        │  z_t = h(x_t)           ← 非線性
│  → KF 公式失效！ │
└────────┬────────┘
         │ 解法：Jacobian 線性化
         ▼
┌─────────────────┐
│  EKF            │  F = ∂f/∂x  取代 A
│  (局部線性化)    │  H = ∂h/∂x  重新計算
│  → 近似用 KF    │
└─────────────────┘
```

**核心邏輯**：
1. KF 需要線性（數學限制）
2. 真實世界是非線性（物理現實）
3. Jacobian 在當前點做切線近似（橋接方案）
4. 這就是 Extended Kalman Filter 的「Extended」

---

## 9. 補充：兩種「非線性」問題，別搞混

在 SLAM 和狀態估計中，「非線性」這個詞其實指兩種不同的問題：

### 問題 1：方程式是非線性函數

```
運動方程：x_t = f(x_{t-1}, u_t)  ← 有 sin、cos
觀測方程：z_t = h(x_t)          ← 有 arctan、sqrt

特徵：函數本身是曲線，不是直線
影響：高斯輸入 → 經過非線性函數 → 輸出不再是高斯
解法：EKF（用 Jacobian 線性化）
```

**例子**：
```
x ~ N(0, 1) 是高斯

經過 y = 2x + 3（線性）→ y 還是高斯 ✓
經過 y = x²（非線性）→ y 變卡方分佈，不是高斯 ✗

EKF 的做法：在 x₀ 附近把 x² 近似成切線 y ≈ 2x₀ × x
這樣高斯進去還是高斯出來
```

### 問題 2：分佈本身不是高斯（多峰）

```
正常高斯：一個山峰，對稱鐘形
非高斯：多個山峰（multimodal），或不對稱

特徵：不確定性沒辦法用「均值 + 方差」描述
影響：KF 和 EKF 都失效（它們假設單峰高斯）
解法：粒子濾波（Particle Filter）
```

**例子**：
```
機器人在對稱走廊，不知道自己在左邊還是右邊
→ 位置的分佈是「雙峰」的
→ 你沒辦法說「我在中間，但不確定度很大」
→ 要用粒子：一半粒子在左邊，一半在右邊
```

### 對照表

| | 問題 1：非線性函數 | 問題 2：非高斯分佈 |
|---|---|---|
| **是什麼** | sin、cos、arctan 等曲線函數 | 多峰、不對稱的分佈 |
| **為何是問題** | 高斯經過後變形 | 無法用均值+方差表示 |
| **KF 能解嗎** | ❌ | ❌ |
| **EKF 能解嗎** | ✅ 用 Jacobian | ❌ |
| **要用什麼** | EKF | 粒子濾波 |

### 常見情境

```
簡單情況（線性 + 高斯）→ 標準 Kalman Filter
         ↓ 如果方程式有 sin/cos
非線性函數 + 高斯 → EKF（Jacobian 線性化）
         ↓ 如果分佈是多峰的
非線性函數 + 非高斯 → 粒子濾波
```

**本筆記講的是第一種：用 Jacobian 處理非線性函數。**

粒子濾波會在後續筆記整理。

---

## 10. EKF-SLAM 的狀態向量

在 SLAM 中，狀態不只有機器人位姿，還包含地圖點：

```
狀態向量 x = [機器人位姿, 地圖點1, 地圖點2, ..., 地圖點N]

例如 2D SLAM：
x = [x_r, y_r, θ_r, x_1, y_1, x_2, y_2, ..., x_N, y_N]
     └──機器人──┘  └─地圖點1─┘ └─地圖點2─┘
```

**狀態維度**：3 + 2N（機器人 3 個自由度 + N 個 2D 地圖點）

這也是 EKF-SLAM 的缺點：狀態維度隨地圖點數量增長，計算量 O(N²)。

---

## 11. 下一步：EKF 的完整演算法

Part 2 會涵蓋：
- 預測步驟（Prediction）的數學推導
- 更新步驟（Update）的數學推導
- Kalman Gain 的意義
- 協方差矩陣的傳遞
- 完整的 EKF-SLAM 演算法流程

---

## 12. 從方程式到 Sensor Fusion：完整的邏輯鏈

前面講了很多數學，現在把整個邏輯串起來。

### 回顧：兩個方程式的本質

```
運動方程式：x_t = f(x_{t-1}, u_t) + w_t   ← 「預測」狀態會怎麼變
觀測方程式：z_t = h(x_t) + v_t            ← 「觀測」狀態是什麼
```

**關鍵洞察**：這兩個方程式給出了**同一個狀態的兩種估計**：
1. 運動方程式：根據「上一刻 + 控制輸入」**預測**現在狀態
2. 觀測方程式：根據「感測器讀數」**觀測**現在狀態

這兩個估計通常不一樣，因為都有雜訊。

---

### EKF-SLAM 的 Predict-Update 循環

EKF 的核心就是不斷重複兩個步驟：

```
┌─────────────────────────────────────────────────────────────┐
│  PREDICT（預測）                                             │
│                                                             │
│  輸入：上一刻狀態 x_{t-1}、控制指令 u_t（例如 IMU 數據）      │
│                                                             │
│  計算：                                                      │
│    x̂_t⁻ = f(x̂_{t-1}, u_t)        ← 預測狀態                │
│    P_t⁻ = F P_{t-1} Fᵀ + Q        ← 預測不確定性（變大！）   │
│                                                             │
│  結果：得到「預測分布」N(x̂_t⁻, P_t⁻)                        │
└─────────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────────┐
│  UPDATE（更新）                                              │
│                                                             │
│  輸入：觀測值 z_t（例如 GPS 位置）、預測分布                  │
│                                                             │
│  計算：                                                      │
│    K = P_t⁻ Hᵀ (H P_t⁻ Hᵀ + R)⁻¹  ← Kalman Gain            │
│    x̂_t = x̂_t⁻ + K(z_t - h(x̂_t⁻))  ← 融合後的狀態          │
│    P_t = (I - KH) P_t⁻              ← 融合後不確定性（變小！）│
│                                                             │
│  結果：得到「融合分布」N(x̂_t, P_t)                          │
└─────────────────────────────────────────────────────────────┘
```

**注意不確定性的變化**：
- Predict 後：P 變大（因為運動有雜訊，越來越不確定）
- Update 後：P 變小（因為觀測提供了新資訊，更確定了）

---

### 本質：高斯分布的融合

上面的數學公式看起來複雜，但**本質非常簡單**：

**Predict 給你一個高斯分布**：
```
預測分布：N(μ_pred, σ²_pred)
         └─ 均值是預測位置，方差是不確定性
```

**觀測給你另一個高斯分布**：
```
觀測分布：N(μ_obs, σ²_obs)
         └─ 均值是觀測位置，方差是感測器雜訊
```

**Kalman Filter 把兩個融合成一個更好的高斯分布**：
```
融合分布：N(μ_fused, σ²_fused)
         └─ 不確定性比任一來源都小！
```

### 融合公式（一維簡化版）

```
Kalman Gain:
    K = σ²_pred / (σ²_pred + σ²_obs)

融合均值:
    μ_fused = μ_pred + K × (μ_obs - μ_pred)
            = (1-K) × μ_pred + K × μ_obs     ← 加權平均！

融合方差:
    σ²_fused = (1-K) × σ²_pred
```

**直覺理解**：
- K 大（預測不確定）→ 更相信觀測
- K 小（觀測不確定）→ 更相信預測
- 融合後的 σ² 一定比兩個來源都小

---

### 從控制理論到 Sensor Fusion

現在你可以理解，為什麼 Kalman Filter 能從「控制理論」變成「Sensor Fusion」：

| 控制理論視角 | Sensor Fusion 視角 |
|-------------|-------------------|
| 運動方程式 + 預測 | Sensor A（例如 IMU）|
| 觀測方程式 + 更新 | Sensor B（例如 GPS）|
| 融合成最佳估計 | 融合成最佳估計 |

**數學完全一樣**，只是解讀方式不同！

### 實際例子：IMU + GPS 融合

```
時間軸：
t=0.00s  IMU predict → x̂, P↑
t=0.01s  IMU predict → x̂, P↑
t=0.02s  IMU predict → x̂, P↑
  ...    （P 越來越大，越來越不確定）
t=0.10s  GPS update  → x̂ 校正, P↓ ← Kalman Gain 融合兩個高斯
t=0.11s  IMU predict → x̂, P↑
t=0.12s  IMU predict → x̂, P↑
  ...
t=0.20s  GPS update  → x̂ 校正, P↓
```

**IMU（高頻 100Hz）**：提供連續的預測，但不確定性會累積
**GPS（低頻 10Hz）**：定期校正，把不確定性拉回來

這就是為什麼 Kalman Filter 是**不同頻率、不同特性**感測器融合的標準方法。

---

### 總結：完整邏輯鏈

```
1. 運動方程式（描述狀態怎麼變）
   └─ 對應：IMU、輪速計等「給變化量」的 sensor
   └─ 產生：預測分布 N(μ_pred, σ²_pred)

2. 觀測方程式（描述狀態是什麼）
   └─ 對應：GPS、LiDAR 定位等「直接量狀態」的 sensor
   └─ 產生：觀測分布 N(μ_obs, σ²_obs)

3. Kalman Filter 融合
   └─ 計算 Kalman Gain K（根據各自不確定性）
   └─ 加權平均得到融合分布 N(μ_fused, σ²_fused)
   └─ 融合後不確定性一定更小！

4. 這就是 Sensor Fusion
   └─ 不是「選一個比較準的」
   └─ 而是「根據可信度加權融合」
   └─ 結果比任何單一來源都好
```

---

## 參考資料

- Cyrill Stachniss SLAM Course
- Probabilistic Robotics (Thrun, Burgard, Fox)
- 多視圖幾何（Hartley & Zisserman）
